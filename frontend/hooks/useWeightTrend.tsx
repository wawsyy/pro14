"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These files are auto-generated by genabi.mjs
import { WeightTrendAddresses } from "@/abi/WeightTrendAddresses";
import { WeightTrendABI } from "@/abi/WeightTrendABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type WeightTrendInfoType = {
  abi: typeof WeightTrendABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getWeightTrendByChainId(
  chainId: number | undefined
): WeightTrendInfoType {
  if (!chainId) {
    return { abi: WeightTrendABI.abi };
  }

  const entry =
    WeightTrendAddresses[chainId.toString() as keyof typeof WeightTrendAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: WeightTrendABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: WeightTrendABI.abi,
  };
}

export const useWeightTrend = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [todayWeightHandle, setTodayWeightHandle] = useState<string | undefined>(undefined);
  const [trendHandle, setTrendHandle] = useState<string | undefined>(undefined);
  const [clearTodayWeight, setClearTodayWeight] = useState<ClearValueType | undefined>(undefined);
  const [clearTrend, setClearTrend] = useState<ClearValueType | undefined>(undefined);
  const clearTodayWeightRef = useRef<ClearValueType>(undefined);
  const clearTrendRef = useRef<ClearValueType>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isComparing, setIsComparing] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const weightTrendRef = useRef<WeightTrendInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);
  const isComparingRef = useRef<boolean>(isComparing);

  const isTodayWeightDecrypted = todayWeightHandle && todayWeightHandle === clearTodayWeight?.handle;
  const isTrendDecrypted = trendHandle && trendHandle === clearTrend?.handle;

  const weightTrend = useMemo(() => {
    const c = getWeightTrendByChainId(chainId);
    weightTrendRef.current = c;
    if (!c.address) {
      setMessage(`WeightTrend deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!weightTrend) {
      return undefined;
    }
    return (Boolean(weightTrend.address) && weightTrend.address !== ethers.ZeroAddress);
  }, [weightTrend]);

  const canGetTodayWeight = useMemo(() => {
    return weightTrend.address && ethersReadonlyProvider && !isRefreshing;
  }, [weightTrend.address, ethersReadonlyProvider, isRefreshing]);

  const refreshTodayWeight = useCallback(() => {
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !weightTrendRef.current ||
      !weightTrendRef.current?.chainId ||
      !weightTrendRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setTodayWeightHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = weightTrendRef.current.chainId;
    const thisAddress = weightTrendRef.current.address;

    const contract = new ethers.Contract(
      thisAddress,
      weightTrendRef.current.abi,
      ethersReadonlyProvider
    );

    contract
      .getTodayWeight()
      .then((value) => {
        if (
          sameChain.current(thisChainId) &&
          thisAddress === weightTrendRef.current?.address
        ) {
          setTodayWeightHandle(value);
        }
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        // Ensure error message is a string to avoid rendering objects
        const errorMsg = e instanceof Error 
          ? e.message 
          : typeof e === 'object' && e !== null && ('hash' in e || 'blockNumber' in e)
          ? "Transaction processing failed, please try again"
          : String(e);
        setMessage("WeightTrend.getTodayWeight() call failed! error=" + errorMsg);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain]);

  useEffect(() => {
    refreshTodayWeight();
  }, [refreshTodayWeight]);

  const canDecryptTodayWeight = useMemo(() => {
    return (
      weightTrend.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      todayWeightHandle &&
      todayWeightHandle !== ethers.ZeroHash &&
      todayWeightHandle !== clearTodayWeight?.handle
    );
  }, [
    weightTrend.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    todayWeightHandle,
    clearTodayWeight,
  ]);

  const decryptTodayWeight = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!weightTrend.address || !instance || !ethersSigner) {
      return;
    }

    if (todayWeightHandle === clearTodayWeightRef.current?.handle) {
      return;
    }

    if (!todayWeightHandle) {
      setClearTodayWeight(undefined);
      clearTodayWeightRef.current = undefined;
      return;
    }

    if (todayWeightHandle === ethers.ZeroHash) {
      setClearTodayWeight({ handle: todayWeightHandle, clear: BigInt(0) });
      clearTodayWeightRef.current = { handle: todayWeightHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisAddress = weightTrend.address;
    const thisHandle = todayWeightHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Start decrypting today's weight...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== weightTrendRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [weightTrend.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        const res = await instance.userDecrypt(
          [{ handle: thisHandle, contractAddress: thisAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setClearTodayWeight({ handle: thisHandle, clear: res[thisHandle] });
        clearTodayWeightRef.current = {
          handle: thisHandle,
          clear: res[thisHandle],
        };

        setMessage(
          "Today's weight decrypted: " + clearTodayWeightRef.current.clear
        );
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    weightTrend.address,
    instance,
    todayWeightHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  const canSubmitWeight = useMemo(() => {
    return (
      weightTrend.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [weightTrend.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  const submitWeight = useCallback(
    (weight: number) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!weightTrend.address || !instance || !ethersSigner || weight <= 0) {
        return;
      }

      const thisChainId = chainId;
      const thisAddress = weightTrend.address;
      const thisEthersSigner = ethersSigner;

      const contract = new ethers.Contract(
        thisAddress,
        weightTrend.abi,
        thisEthersSigner
      );

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage(`Submitting weight ${weight}...`);

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== weightTrendRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisAddress,
            thisEthersSigner.address
          );
          input.add32(weight);

          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore submitWeight");
            return;
          }

          setMessage("Call submitWeight...");

          const tx: ethers.TransactionResponse = await contract.submitWeight(
            enc.handles[0],
            enc.inputProof
          );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`SubmitWeight completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore submitWeight");
            return;
          }

          refreshTodayWeight();
        } catch (e) {
          // Ensure error message is a string to avoid rendering objects
          const errorMsg = e instanceof Error 
            ? e.message 
            : typeof e === 'object' && e !== null && ('hash' in e || 'blockNumber' in e)
            ? "Transaction processing failed, please try again"
            : String(e);
          setMessage(`SubmitWeight Failed! ${errorMsg}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      weightTrend.address,
      weightTrend.abi,
      instance,
      chainId,
      refreshTodayWeight,
      sameChain,
      sameSigner,
    ]
  );

  const canCompareTrend = useMemo(() => {
    return (
      weightTrend.address &&
      ethersSigner && // Need signer because compareWeightTrend is nonpayable
      !isRefreshing &&
      !isComparing
    );
  }, [weightTrend.address, ethersSigner, isRefreshing, isComparing]);

  const compareTrend = useCallback(() => {
    if (isRefreshingRef.current || isComparingRef.current) {
      return;
    }

    if (
      !weightTrendRef.current ||
      !weightTrendRef.current?.chainId ||
      !weightTrendRef.current?.address ||
      !ethersSigner // Need signer because compareWeightTrend is nonpayable
    ) {
      setTrendHandle(undefined);
      setMessage("Please connect wallet to compare weight trend");
      return;
    }

    isComparingRef.current = true;
    setIsComparing(true);
    setMessage("Comparing weight trend...");

    const thisChainId = weightTrendRef.current.chainId;
    const thisAddress = weightTrendRef.current.address;
    const thisEthersSigner = ethersSigner;

    const contract = new ethers.Contract(
      thisAddress,
      weightTrendRef.current.abi,
      thisEthersSigner // Use signer instead of readonly provider
    );

    const run = async () => {
      try {
        const isStale = () =>
          thisAddress !== weightTrendRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        setMessage("Calling compareWeightTrend...");

        // compareWeightTrend is nonpayable and will send a transaction
        // In ethers.js v6, nonpayable functions with return values may return TransactionResponse
        // We need to check the return type and handle it correctly
        
        const result = await contract.compareWeightTrend();
        
        // Check return type: if TransactionResponse, wait for confirmation then use staticCall
        let encryptedTrend: string;
        
        if (result && typeof result === 'object' && 'hash' in result && 'wait' in result) {
          // Returned TransactionResponse, need to wait for confirmation
          const tx = result as ethers.TransactionResponse;
          setMessage(`Waiting for transaction confirmation: ${tx.hash}...`);
          
          const receipt = await tx.wait();
          
          if (isStale()) {
            setMessage("Ignoring compareWeightTrend result");
            return;
          }

          if (!receipt || receipt.status !== 1) {
            setMessage("Transaction failed, please try again");
            return;
          }

          // Wait for FHE.allow() authorization to take effect
          // This is especially important for mock FHEVM where state updates may be async
          setMessage("Waiting for authorization to take effect...");
          await new Promise(resolve => setTimeout(resolve, 3000));

          if (isStale()) {
            setMessage("Ignoring compareWeightTrend result");
            return;
          }

          // After confirmation, use staticCall to get return value
          // The handle returned should be authorized since FHE.allow() was called in the transaction
          setMessage("Getting comparison result...");
          const callResult = await contract.compareWeightTrend.staticCall();
          
          // Ensure return value is a string
          if (typeof callResult === 'string') {
            encryptedTrend = callResult;
          } else {
            encryptedTrend = String(callResult);
          }
        } else if (typeof result === 'string') {
          // Directly returned string (ebool handle)
          encryptedTrend = result;
        } else {
          // Other cases, convert to string
          encryptedTrend = String(result);
        }

        if (isStale()) {
          setMessage("Ignoring compareWeightTrend result");
          return;
        }

        // Check return value
        if (!encryptedTrend || encryptedTrend === ethers.ZeroHash || encryptedTrend === "0x0000000000000000000000000000000000000000000000000000000000000000") {
          setMessage("No trend data available (need at least 2 days of data)");
          setTrendHandle(ethers.ZeroHash);
        } else {
          setMessage(`Comparison completed, encrypted trend result obtained`);
          setTrendHandle(encryptedTrend);
        }

        if (isStale()) {
          setMessage("Ignoring compareWeightTrend result");
          return;
        }
      } catch (e) {
        // Ensure error message is a string to avoid rendering objects
        const errorMessage = e instanceof Error 
          ? e.message 
          : typeof e === 'object' && e !== null && ('hash' in e || 'blockNumber' in e)
          ? "Transaction processing failed, please try again"
          : String(e);
        setMessage(`WeightTrend.compareWeightTrend() call failed! error=${errorMessage}`);
        console.error("compareWeightTrend error:", e);
      } finally {
        isComparingRef.current = false;
        setIsComparing(false);
      }
    };

    run();
  }, [ethersSigner, sameChain, sameSigner]);

  const canDecryptTrend = useMemo(() => {
    return (
      weightTrend.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      trendHandle &&
      trendHandle !== ethers.ZeroHash &&
      trendHandle !== clearTrend?.handle
    );
  }, [
    weightTrend.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    trendHandle,
    clearTrend,
  ]);

  const decryptTrend = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!weightTrend.address || !instance || !ethersSigner) {
      return;
    }

    if (trendHandle === clearTrendRef.current?.handle) {
      return;
    }

    if (!trendHandle) {
      setClearTrend(undefined);
      clearTrendRef.current = undefined;
      return;
    }

    if (trendHandle === ethers.ZeroHash) {
      setClearTrend({ handle: trendHandle, clear: false });
      clearTrendRef.current = { handle: trendHandle, clear: false };
      return;
    }

    const thisChainId = chainId;
    const thisAddress = weightTrend.address;
    const thisHandle = trendHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Start decrypting trend...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== weightTrendRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [weightTrend.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        // Wait a bit to ensure authorization is fully processed
        // This is especially important for mock FHEVM
        await new Promise(resolve => setTimeout(resolve, 500));

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        // Use userDecrypt method to decrypt ebool (same way as decrypting euint32)
        // Retry logic for authorization issues
        let res;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          try {
            res = await instance.userDecrypt(
              [{ handle: thisHandle, contractAddress: thisAddress }],
              sig.privateKey,
              sig.publicKey,
              sig.signature,
              sig.contractAddresses,
              sig.userAddress,
              sig.startTimestamp,
              sig.durationDays
            );
            break; // Success, exit retry loop
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            if (errorMessage.includes("not authorized") && retryCount < maxRetries - 1) {
              retryCount++;
              setMessage(`Authorization pending, retrying (${retryCount}/${maxRetries})...`);
              // Wait longer before retry
              await new Promise(resolve => setTimeout(resolve, 2000 * retryCount));
              
              if (isStale()) {
                setMessage("Ignore FHEVM decryption");
                return;
              }
              continue;
            } else {
              // Re-throw if not authorization error or max retries reached
              throw error;
            }
          }
        }

        if (!res) {
          setMessage("Failed to decrypt trend after retries");
          return;
        }

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        // res is a DecryptedResults object, key is handle, value is decrypted value (boolean for ebool)
        const decryptedValue = res[thisHandle];
        
        // Ensure value is boolean type
        const clearTrend: boolean = typeof decryptedValue === 'boolean' 
          ? decryptedValue 
          : typeof decryptedValue === 'bigint' 
            ? decryptedValue !== BigInt(0) 
            : Boolean(decryptedValue);

        setClearTrend({ handle: thisHandle, clear: clearTrend });
        clearTrendRef.current = {
          handle: thisHandle,
          clear: clearTrend,
        };

        setMessage(
          "Trend decrypted: " + (clearTrend ? "Weight decreased! ðŸ“‰" : "Weight increased or same ðŸ“ˆ")
        );
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    weightTrend.address,
    instance,
    trendHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  return {
    contractAddress: weightTrend.address,
    canGetTodayWeight,
    canDecryptTodayWeight,
    canSubmitWeight,
    canCompareTrend,
    canDecryptTrend,
    submitWeight,
    refreshTodayWeight,
    decryptTodayWeight,
    compareTrend,
    decryptTrend,
    isTodayWeightDecrypted,
    isTrendDecrypted,
    message,
    clearTodayWeight: clearTodayWeight?.clear,
    clearTrend: clearTrend?.clear,
    todayWeightHandle,
    trendHandle,
    isDecrypting,
    isRefreshing,
    isSubmitting,
    isComparing,
    isDeployed,
  };
};


